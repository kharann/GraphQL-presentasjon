import { themes } from "mdx-deck";
import { CodeSurfer, CodeSurferColumns, Step } from "code-surfer";
import { dracula, shadesOfPurple } from "@code-surfer/themes";
import { dracula as dracula2 } from "react-syntax-highlighter/dist/cjs/styles/prism";

<!-- Remind me to never use MDX-Deck again because holy shit this is hacky and buggy as hell -->

export const theme = {
  ...themes.dark,
  components: {
    ...themes.prism.components,
    code: (props) =>
      themes.prism.components.code({
        ...props,
        className: props.className.replace("graph", `${"graph" + "ql"}`),
        style: dracula2,
      }),
  },
};

<Split>

<img
  src={require("./assets/xd.png")}
  style={{ width: "100%", padding: "4rem" }}
/>

# Kurs i GraphQL ü§Ø

</Split>

<Notes>

- Velkomme alle sammen!

</Notes>

---

# <span style={{color: '#01E700'}}>$</span> whoami

- Anhkha, 3 Klasse Informatikk :wave:.
- Ny i Junior Consulting!

---

# M√•let med kurset :rocket:

- L√¶re litt om bakgrunnen bak GraphQL.
- L√¶re forskjellen mellom REST og GraphQL.
- L√¶re grunnprinsippen bak GraphQL slik at man kan lage et API i hvilket s√• helst spr√•k.
- L√¶re arbeidsmetodikk tett knyttet opp med GraphQL.

---

# GraphQL pr√∏ver √• l√∏se noen av problemene ved REST

- GraphQL var utviklet for √• f√• mer <span style={{"color" : "#F0389C"}}>**fleksibilitet og effektivitet**</span> i client-server kommunikasjon

<SplitRight>
<img
  src={require("./assets/rest_api.png")}
  style={{ width: "100%" }}
/>

<Steps>

- Et endepunkt her, og et endepunkt der...
- Endepunktet gir ikke all dataen du trenger.
- Endepunktet gir ALTFOR mye data.
- Det er ikke intuitivt hvordan man gj√∏r noen ting.

</Steps>
</SplitRight>

---

<SplitRight>
<img
  src={require("./assets/Peek 2021-04-17 14-02.gif")}
  style={{ width: "100%", padding: "1rem" }}
/>

# Det blir fort <span style={{"color" : "#F0389C"}}>rotete</span>

<Steps>

- Usikkerhet rundt typing p√• data.
- Usikkerhet p√• hvor ting ligger!
- Vanskelig √• refactore.

</Steps>

</SplitRight>

---

# Forskjellen mellom REST og GraphQL

---

# REST vs GraphQL, Data Fetching

<Split>

<img
  src={require("./assets/fetching_old.png")}
  style={{ width: "100%", padding: "1rem" }}
/>
<img
  src={require("./assets/fetching.png")}
  style={{ width: "100%", padding: "1rem" }}
/>

</Split>

<Notes>

- Klassisk REST har flere endepunkter for ulike ting.
- Man kan ha et endepunkt for brukeren, et endepunkt for innlegg som brukeren har lagd og et endepunkt for f√∏lgere av brukeren.
- Med GraphQL sender man en sp√∏rring ("query"), som forklarer hva API kallet √∏nsker √• gj√∏re.
- I dette tilfellet vil den hente en bruker, med f√∏lgende ID, med disse feltene i tillegg til innlegg og de 3 siste f√∏lgerene.

</Notes>

---

# Hvilket problemer l√∏ser dette?

<Steps>

- Ingen overfetching üì¶.
  - Slipper √• fetche un√∏dvendig data.
- Ingen underfetching og N+1 problemet ü§è.
  - All dataen man trenger for en side er ikke i endepunktet.
  - For √• vise alle brukere med f√∏lgere s√• m√• man fetche `/users` og deretter `/users/<user_id>/followers` per bruker.
- Hyppig iterativ prosess av produktet p√• frontend-en üèÉ‚Äç‚ôÇÔ∏è.

</Steps>

<Notes>

- Man slipper √• fetche for mye, og un√∏dvendig data. Bandwidth friendly
- N+1 betyr at man m√• fetche en ekstra gang, per N gang
- For √• vise alle f√∏lgere, s√• m√• man fetche `/users`, og deretter `/users/<user_id>/followers` for hver bruker
- Vanlig √• kategorisere endepunkter basert p√• views. Man trenger ikke √• gj√∏re flere GET kalls for √• f√• all dataen man trenger for en side
- Med REST s√• er det en risiko at med hver endring til UIet (gjennom feedbacks) kan kreve endringer i hvilken data som vises.

</Notes>

---

<CodeSurferColumns themes={[dracula, shadesOfPurple ]}>

<Step title="Det er mulig √• autogenere typer i frontenden for f.eks. TypeScript, Kotlin og Swiftü§Ø">

```graph showNumbers subtitle="GraphQL Schema"
type User {
  id: ID!
  email: String!
  age: Int
}
```

```typescript showNumbers subtitle="TypeScript"
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};

export type User = {
  __typename?: "User";
  id: Scalars["ID"];
  email: Scalars["String"];
  age?: Maybe<Scalars["Int"]>;
};
```

</Step>

<Step title="Her ser man at GraphQL typen matcher TypeScript typenü§ù">

```diff 1:5

```

```diff 9:14

```

</Step>
</CodeSurferColumns>

<Notes>

- Man kan autogenere typer.
- Om du utvikler i Kotlin, Swift eller typescript.
- Noen rare ord her, hva er en Skalar?

</Notes>

---

# GraphQL 101

<Steps>

- GraphQL er skrevet med en syntax som heter SDL (Schema Definition Language).
- GraphQL bruker sitt eget type-system
- Scalars er rot-typer som ikke inneholder noe n√∏stet data.
- Vi har 5 "Scalars" som er innebygd by default:
  - String
  - Int
  - Float
  - Boolean
  - ID

</Steps>

---

<CodeSurfer theme={dracula}>

```graph showNumbers title="Intro til √• definere schema med SDL"
type User {
  id: ID!
  email: String!
  age: Int
}
```

```diff 2,3 subtitle='Her definers "Field"-ene id og email. Utropstegnet markerer feltet som non-nullable'


```

```diff 4 subtitle='Feltet "age" er dermed en nullable-verdi''

```

```graph showNumbers subtitle='Vi legger til en "Country"-type for √• lage en relasjon'
type Country {
  code: ID!
  name: String!
}

type User {
  id: ID!
  email: String!
  age: Int
  birthplace: Country!
}
```

```graph showNumbers subtitle='Vi lager en "Allergy"-enum og kobler den til brukeren.'
enum Allergy {
  MILK
  GLUTEN
  PEANUTS
}

type Country {
  code: ID!
  name: String!
}

type User {
  id: ID!
  email: String!
  age: Int
  birthplace: Country!
  allergies: [Allergy!]!
}
```

```diff title='Selv med f√• "Scalars" s√• kan man f√• til ganske mye'

```

</CodeSurfer>

<Notes>

- Begynner med keywordet "type" n√•r vi definere en type
- Ligner litt p√• TypeScript
- Man m√• v√¶re eksplisitt n√•r noe er non-nullable i SDL iforhold til typescript, kotlin osv.
- Man definere en relasjon ved √• skrive type-navnet
- Vi definere en enum med n√∏kkelordet enum
- Utroppstegnet inni klammene sier at ingen av enhetene p√• innsiden kan v√¶re null.
- Utroppstegnet p√• utsiden sier at listen m√• finnes, slik at vi kan f√• en tom liste istedenfor null

</Notes>

---

# GraphQL 101: The Schemaüßë‚Äçüè´

- Ditt GraphQL Schema forteller klienten hva den kan og ikke kan gj√∏re.
- Kan bli sett p√• som en <span style={{"color" : "#F0389C"}}>kontrakt</span> mellom server og klient om hvordan APIet skal se ut.
- Best√•r av tre spesielle rot-typer som blir kalt "Operations"

<!-- Ordet graph ql i et ord brekker heller gatsby parseren. Sykt kult -->

```graph

```

---

<CodeSurferColumns themes={[dracula, shadesOfPurple]}>

<Step title="GraphQL 101: En sp√∏rringüîé">

```graph showNumbers
enum Allergy {
  MILK
  GLUTEN
  PEANUTS
}

type Country {
  code: ID!
  name: String!
}

type User {
  id: ID!
  email: String!
  age: Int
  birthplace: Country!
  allergies: [Allergy!]!
}

type Query {
  findUserById(id: ID!): User
  findAllusers: [User!]!
}

type Mutation {
  createUser(email: String!, age: Int): User
}

type Subscription {
  userCreated: User
}
```

```graph showNumbers
  query {
    findAllUsers {
      id
      email
    }
  }
```

</Step>

<Step subtitle="Man matcher p√• operasjonen 'Query'">

```diff 20[6:11]

```

```diff 1[3:8]

```

</Step>

<Step subtitle="Deretter velger man en av feltene som ligger i operasjonen">

```diff 21

```

```diff 2

```

</Step>

<Step subtitle="Resultatet er en 'User', s√• vi m√• velge felter som finnes i 'User'-typen">

```diff 12:14,18,21[25:30]

```

```diff 2:4

```

</Step>

<Step subtitle="Om man √∏nsker √• utf√∏re en mutation, s√• m√• man ha 'mutation' ytterst i sp√∏rringen">

```diff 25:27

```

```graph showNumbers
  query {
    findAllUsers {
      id
      email
    }
  }

  mutation CreateUser($email: ID!) {
    createUser(email: $email) {
      id
      email
    }
  }
```

</Step>

<Step subtitle="Det er mulig √• navngi sp√∏rringene dine, og sette input-variablene dynamisk">

```diff

```

```diff 8[11:34],9[23:29]

```

</Step>

<Step subtitle="La oss sp√∏r om mer data! Vi vil ha med 'age' og 'birthplace'">

```diff 7:10,12,15,16,18

```

```graph showNumbers
  query {
    findAllUsers {
      id
      email
      age
      birthplace {
        code
        name
      }
    }
  }

  mutation CreateUser($email: ID!) {
    createUser(email: $email) {
      id
      email
      age
      birthplace {
        code
        name
      }
    }
  }
```

</Step>

<Step subtitle="GraphQL er ekstremt fleksibelt, og du kan tilpase dine sp√∏rringer til dine krav">

```diff

```

```diff

```

</Step>

</CodeSurferColumns>

<Notes>

- P√• venstre s√• har vi Schemaet v√•rt, p√• h√∏yre har vi en sp√∏rring

</Notes>

---

# GraphQL 101: The playground üé®

- GraphQL inneholder et nyttig verkt√∏y som heter playground
- Inneholder typedokumentasjon, god auto-complete og en fin schema-explorer

---

Et GraphQL api med oversikt over land og kontinenter: https://countries.trevorblades.com

---

<CodeSurfer theme={dracula} >

```graph showNumbers
type User {
  id: ID!
  email: String!
  age: Int
}
```

```graph showNumbers
enum Allergy {
  MILK
  GLUTEN
  PEANUTS
}

type User {
  id: ID!
  email: String!
  age: Int
  allergies: [Allergy!]!
}

type Query {
  findUser(id: ID!): User
  findAllUsers: [User]!
}

type Mutation {
  createUser(email: String!, age: Int): User
}
```

</CodeSurfer>
